# BLOB SCOREBOARD
#### Video Demo: https://youtu.be/Bl867w63ILs
#### Description:
For my final project, I decided to create a web-application using Flask, Python, SQL, and Javascript. The web-app is a scoreboard to be used with a card game that my friends and I call 'Blob'. Blob is a variant of the card game [Oh Hell](https://en.wikipedia.org/wiki/Oh_Hell). Blob is a trick-betting, round based card game played with a standard deck of 52 playing cards in which the players must match each round's bet *exactly* or else they 'blob'. 

**Gameplay**: 
There are 14 rounds during a game of Blob, starting with 1 going up to 7, repeating 7, and then going back down to 1. The number of each round is also the number of cards that each player will be dealt for that round. The game begins by choosing a dealer. Our friends choose randomly though others deal out one card to each person and the lowest card becomes the first dealer. The dealer then begins the game at round 1 by giving each player, starting to the left of the dealer, 1 card. After all players have received the correct number of cards, the betting begins. Players are betting how many tricks they will win each round. If players do not match their bets *exactly* then their bet is filled in with a black circle, or a blob. All cards are collected and given to the next dealer, the player to the left of the most recent dealer. The cards are shuffled and the next round begins. At the end of the game, the player with the least number of blobs is the winner.

**Rules**:  
- Betting must be done after the cards are dealt and before any cards are turned over. 
- Bets can be between 0 and the number of the round. For example, in round 5, each player can bet anything between 0 and 5 because each player only has 5 cards.
- Betting begins with the player to the left of the dealer and goes clockwise until the dealer finally bets.
- The total number of each player's bets cannot be equal to the round number. This is because one player must blob every round. Betting last, the dealer usually has the    disadvantage.
- The winner of each trick is determined based on the suit and card value that is placed down. 
- Hearts are the trump suit; they beat every other suit in the game. Within suits, the value of the cards range from the lowest valued 2 card to the highest valued Ace card.
- The first player of each round begins with an advantage. The lead suit, the first card placed each trick, must be played if a player has that suit even if it means a loss. 
- At the end of the game, if there is a tie between players with the least amount of blobs, then the player with the least amount of blobs and the most successful bets wins. 
- In the rare event of a tie in bets and blobs, there is no winner. 

**Files**: The main file of my project is the python file **app.py**. The libraries used are sqlite3, and from flask, Flask, request, and render_template. App.py has 4 routes and functions: a route and function for index, a route and function for 'homepage', a route and function for 'leaderboard', and a route and function for 'scoreboard'.
- index is a simple route and function that renders the 'index.html' template.
- homepage is also a simple route and function that renders the 'homepage.html' template.
- leaderboard is a route and function that can take both GET and POST methods. If the method is GET, the function makes a connection to players.db, it selects all the information from the players table in players.db, it sorts the information in descending order based on the 'wins' column, it commits and closes the connection to players.db, and then it renders the 'leaderboard.html' template sending a list of dictionaries.
    - If the method is POST, it means that a game has just concluded and data from the game needs to be requested. The players' names, bets and blobs are requested in the form of lists and an empty dictionary is initialized. There are then 3 for loops that go through each list of players, bets, and blobs, and adds the information as a dictionary to the original empty dictionary. Next, the winner of the game is determined by looping through the dictionary and comparing blob counts and bet counts. Next, a connection is made to players.db and the 'blobs' and 'wins' columns are updated. Finally, the new information is selected from players.db, the information is sorted by wins in descending order, and the information is sent to 'leaderboard.html' .
- scoreboard is a route and function that begins by starting a connection to players.db and creating a table if it does not exist and then selecting all of the entries in the name column of the players table. Next, it adds each name to a list called returning_players. If returning_players has no entries, then all of the players' names in current_players are added to the players table in players.db. If returning_players has entries, it will compare each name in current_players to the list of returning_players. If a player's name is in both current_players and returning_players, the loop continues to the next name. If not, that player's name is added to players.db. Finally, the list current_players is sent to scoreboard.html.
- **layout.html** is the main template for all of the html files. It uses a Bootstrap navbar with buttons 'Blob', 'Play', and 'Leaderboard'. Blob links to the index route, Play to the homepage route, and Leaderboard to the leaderboard route.
- **index.html** is the opening page of the website. The 'Let's Play!' button on the page links to the homepage route. I thought the gif of the piece of legal pad was interesting because normally when we play Blob we use a piece of paper like that for the scoreboard.
- **homepage.html** is where users can enter all the players' names that will play the game. The minimum number of players is three. The first three input fields are required so if those are not entered, the browser will show a warning. When the page is initially loaded, there are just two buttons: a person with a + sign and another 'Let's Play!' button. When the + person button is pressed, through Javascript, another input is added for another player name. Additionally, as long as the number of player inputs is more than 3, a new button will appear--a person with a - sign. If pressed, one of the player input fields will be removed. If the number of player inputs goes back to 3, the - person button will be hidden. Lastly, once the number of player input fields reaches 7, if the + person button is pressed again, a modal will appear showing an error as 7 players is the maximum number of players. 
- **scoreboard.html** is the most complicated and functional page in the whole app. This page uses Jinja to create the 'scoreboard' which is just a table of number inputs, and uses Javascript for various edits and popups. First, the table is generated based on the number of players' names filled in on homepage.html. Each row of the scoreboard from round 1 to the final 1 round has a number input in each cell under each player's name. Only the first round's inputs are enabled. When the page is first loaded, a modal pops up to give some basic information on the game. Once the user closes it, the game can begin. After the user enters all of the players' bets and presses the 'Confirm Bets' button, a number of things happen. First, all of the values that were entered for bets are checked for errors. If the bet is higher than the round the highBet_error function is called and the error modal is displayed with an error message. If no bet is entered, the emptyBet_error function is called and an error modal is displayed. If the user enters a negative number, the negativeBet_error function is called and an error modal is displayed. If the sum of all the bets is equal to the round, the dealerBet_error is called and an error modal is displayed. If there are no errors, once the 'Confirm Bets' button is pressed, the innerhtml of the cells that just had bets entered is changed to a p element containing the cell's bet. Next, if the bet turns out to be incorrect, the user can 'blob' the bet by double clicking on the cell. Double clicking on the cell calls the blob function which changes the cell from a number to a black dot. The blob function will also subtract the blobbed bet from the player's total bets and increase the player's total blobs by 1. At the end of the game, once all bets have been entered, the 'Confirm Bets' button changes to 'Calculate Winner' which when pressed calls the calculate function. This function will compare all the players' blob totals, and total bets if needed, to determine the winner. The winner is announced via a modal with a button which will take the user to the leaderboard page.
- **leaderboard.html** if clicked on from the navbar will get all the data from players.db and will list them in a table on the page. If leaderboard.html is accessed from the end of the game button, the game's data is sent to the leaderboard route in app.py, players.db is updated, then the updated data from players.db is sent to leaderboard.html. 
    - I tried to find a way to be able to have sortable columns on the table here but I was unable to. I was spending too much time on that aspect so I decided to pass on it at this time. In the future I would like to come back to that and change it though. For now, I sort the data from players.db on the backend in app.py before sending it to leaderboard.html. 
- **players.db** is a sql database containing one table called players. The table has 4 columns: id, name, wins, blobs.
- **styles.css** contains minimal styling for the app.


**Personal Impressions**:
I'm not sure whether this is appropriate to include but if someone is reading to this point I just want to express how much I appreciate everything all of you involved with CS50 do. This course has changed my life. I never thought I would be able to do any of the things I was able to do in this course. I learned so much both about programming and about myself. This is the first step in my hopeful career in computer science, and I will never forget this experience. Thank you again. 